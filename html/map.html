<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

        <link rel="stylesheet" href="../script/leaflet.css" />
        <link rel="stylesheet" href="../script/leaflet-ruler.css" />
        <link rel="stylesheet" href="../script/easy-button.css" />
        <link rel="stylesheet" href="../script/Control.Coordinates.css" />
        <link rel="stylesheet" href="../script/leaflet.groupedlayercontrol.css" />
        <link rel="stylesheet" href="../script/leaflet-slider.css" />
        <script src="../script/leaflet.js"></script>
        <script src="../script/leaflet-ruler.js"></script>
        <script src="../script/easy-button.js"></script>
        <script src="../script/leaflet-svg-shape-markers.js"></script>
        <script src="../script/L.KML.js"></script>
        <script src="../script/Control.Coordinates.js"></script>
        <script src="../script/leaflet.groupedlayercontrol.js"></script>
        <script src="../script/leaflet.textpath.js"></script>
        <script src="../script/websocket.js"></script>
        <script src="../script/util.js"></script>
        <script src="../script/colormaps.js"></script>
        <script src="../script/leaflet-control.js"></script>
        <script src="../script/leaflet-grids.js"></script>
        <script src="../script/leaflet-slider.js"></script>


        <style>
          .leaflet-toggle-clicked{
              height: 35px;
              width: 35px;
              border-color: chartreuse !important;
              border-width: 4px !important;
          }
        </style>
        <script>
            L.Control.toggle = L.Control.extend({
                onAdd: function(map) {
                    this._map = map;
                    this._container = L.DomUtil.create('div', 'leaflet-bar');
                    this._container.classList.add('leaflet-toggle');
                    L.DomEvent.disableClickPropagation(this._container);
                    L.DomEvent.on(this._container, 'click', this._toggleControl, this);
                    this._choice = false;
                    this._defaultCursor = this._map._container.style.cursor;
                    this._allLayers = L.layerGroup();
                    this._toggle = null;
                    this.toggled = false;
                    return this._container;
                },
                toggled: false,
                onRemove: function(map) {
                    L.DomEvent.off(this._container, 'click', this._toggleControl, this);
                    // Nothing more to do here
                },
                _toggleControl: function() {
                    this.toggled = !this.toggled;
                    console.log('toggled');
                    if (this.toggled)
                        this._container.classList.add("leaflet-toggle-clicked");
                    else
                        this._container.classList.remove("leaflet-toggle-clicked");
                    if (this._toggle) this._toggle(this.toggled);
                    return false;
                },
                configure: function(toggle, html) {
                    this._toggle = toggle;
                    this._container.innerHTML = html; // style.backgroundImage = 'url(' + image + ')';
                    return this;
                }
            });

            L.control.toggle = function(opts) {
                
                return new L.Control.toggle(opts);
            }
        </script>

        <style>
            .incrButton {
                height: 24px;
                width: 24px;
            }
            .leaflet-toggle{
              height: 35px;
              width: 35px;
              background-repeat: no-repeat;
              background-position: center;
            }
            .kml-popup .leaflet-popup-tip,
            .kml-popup table,
            .weather-popup div,
            .weather-popup .leaflet-popup-tip,
            .weather-popup .leaflet-content-wrapper .leaflet-popup-content,
            .weather-popup table,
            .kml-popup .leaflet-popup-content-wrapper {
                background: #e0e0e0;
                color: #234c5e;
                font-family: verdana, arial, tahoma, 'sans serif'; 
                font-size: 10px;
            }
            .leaflet-tooltip-top:before, 
            .leaflet-tooltip-bottom:before, 
            .leaflet-tooltip-left:before, 
            .leaflet-tooltip-right:before {
                border: none !important;
            }

            .assetLabel {
                background: transparent;
                border: none;
                box-shadow: none;
            }
            #info {
                font-family: 'Quattrocento Sans', sans-serif;
                position: absolute;
                font-size: 16px;
                top: 120px;
                right: 10px;
                background-color: rgba(200,200,200,0.5);
                padding: 4px;
                display: none;
                z-index: 700;
            }

            .spanClick          {color:#0000ff; text-decoration:none}
            .spanClick:hover    {color:#0000aa; text-decoration:underline; cursor: pointer; }
            .spanClick:active   {color:#0000aa; text-decoration:underline}

            .hamDiv {
                display: none;
                position: fixed;
                top: 100px;
                right: 100px;
                background-color: rgba(200,200,200,0.5);
                padding: 4px;
                z-index: 10000;
                width: max-content; 
            }

        </style>
    </head>

    <body onunload="saveBounds();">
        <div style="width: 100vw; height: 100vh" id="map"></div>

        <div id="info">
            <div id="basicInfo">
            </div>
            <hr>
            <div id="rangeInfo">
            </div>
            <hr>
            <div id="routeInfo">
            </div>
        </div>

        <div id="hamDiv" class="hamDiv">
            <ul>
                 <li><span class="spanClick" onclick="loadSAFromFile(); toggleHamburger(); return false;">load SA from file</span> 
                <li><span class="spanClick" onclick="clearTail(100); toggleHamburger(); return false;">clear tail (100)</span>
                <li><span class="spanClick" onclick="clearTail(-1); toggleHamburger(); return false;">clear tail (half)</span>
                <li><span class="spanClick" onclick="clearTail(0); toggleHamburger(); return false;">clear tail (all)</span>
                <li><span class="spanClick" onclick="saveTail(); toggleHamburger(); return false;">save ship tail</span>
                <li><span class="spanClick" onclick="loadTail(); toggleHamburger(); return false;">load ship tail</span>
                <li><span class="spanClick" onclick="loadRoutesFromFile(); toggleHamburger(); return false;">load routes</span>
                <li><span class="spanClick" onclick="loadMarks(); toggleHamburger(); return false;">load marks</span>
            </ul>
        </div>
        <div id="heatControlDiv" class="hamDiv">
            <span style="min-width:10px; background-color: rgb(48,18,59); color: white;">min</span>&nbsp;<input id="txtHeatMin" size=7 value="0" oninput="heatControlInputMin();">
            <label for="heatControlAutoMn">auto</label><input type="checkbox" value="auto" id="heatControlAutoMn" checked>
            <input type="button" onclick="heatControlAdjust(false, 1);" value="+" class="incrButton">
            <input type="button" onclick="heatControlAdjust(false, -1);" value="-" class="incrButton">
            <p>
            <span style="min-width:10px; background-color: rgb(122,4,3); color: white;">max</span>&nbsp;<input id="txtHeatMax" size=7 value="0" oninput="heatControlInputMax();">
            <label for="heatControlAutoMx">auto</label><input type="checkbox" value="auto" id="heatControlAutoMx" checked>
            <input type="button" onclick="heatControlAdjust(true, 1);" value="+" class="incrButton">
            <input type="button" onclick="heatControlAdjust(true, -1);" value="-" class="incrButton">
        </div>

        <script type="text/javascript">
            var targetsChannel = null;
            var currentMission = '';

            function xy2magdir(x, y)
            {
                let mag = Math.sqrt(x*x + y*y);
                let dir = Math.atan2(x, y)*180.0/Math.PI;
                if (dir < 0)
                    dir += 360;

                return [mag, dir];
            }

            var needLocationSetup = 0;

            function download(filename, text) {
                var element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
                element.setAttribute('download', filename);

                element.style.display = 'none';
                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }

            function loadRoutesFromFile() {
                var input = document.createElement('input');
                input.type = 'file';

                input.onchange = e => { 

                   var file = e.target.files[0]; 
                   var reader = new FileReader();
                   reader.readAsText(file,'UTF-8');

                   reader.onload = readerEvent => {
                      const lines = readerEvent.target.result.split('\n');
                      var nrt = 0, ddmm = false;
                      routes = [];
                      routes.push([]);
                      var first = 0;
                      if (lines[0].startsWith('#ddmm')) {
                          first = 1;
                          ddmm = true;
                      } 
                      for (var i = first ; i < lines.length ; i++) {
                        const pcs = lines[i].split(' ');
                        if (pcs.length == 2) {
                            if (ddmm)
                                routes[nrt].push({ lat: ddmm2dd(parseFloat(pcs[0])), lon: ddmm2dd(parseFloat(pcs[1])) }); 
                            else
                                routes[nrt].push({ lat: parseFloat(pcs[0]), lon: parseFloat(pcs[1]) }); 
                        }
                        else {
                            routes.push([]);
                            nrt ++; 
                        }
                      }

                      console.log(routes);
                      loadRoutes(map, layerControl, routes, true);
                   }

                }

                input.click();
            }
    
            function loadTail() {
                var input = document.createElement('input');
                input.type = 'file';

                input.onchange = e => { 

                   // getting a hold of the file reference
                   var file = e.target.files[0]; 

                   // setting up the reader
                   var reader = new FileReader();
                   reader.readAsText(file,'UTF-8');

                   // here we tell the reader what to do when it's done reading...
                   reader.onload = readerEvent => {
                      var content = readerEvent.target.result; // this is the content!
                      var remap = false;
                      const lines = content.split('\n');
                      for (var i = 0 ; i < lines.length ; i++) {
                        const pcs = lines[i].split(' ');
                        const t = Date.parse(pcs[2] + 'T' + pcs[3] + ':00Z')/1000;
                        remap = addShipTailMarker(parseFloat(pcs[0]), parseFloat(pcs[1]), t, 
                                                  pcs.length == 5 ? parseFloat(pcs[4]) : null) || remap;
                      }
                      if (remap) {
                        remapShipTail();
                      }
                   }

                }

                input.click();
            }

            function remapShipTail() {
                if (shipTailGroup == null) 
                    return;

                const marks = shipTailGroup.getLayers();
                for (var i = 0 ; i < marks.length ; i++) {
                    if (marks[i].heat) {
                        marks[i].setStyle({color: colormap('turbo', marks[i].heat, shipTailHeatMn, shipTailHeatMx) });
                    }
                }

                if ($('heatControlAutoMn').checked)
                    $('txtHeatMin').value = shipTailHeatMn;
                if ($('heatControlAutoMx').checked)
                    $('txtHeatMax').value = shipTailHeatMx;
            }

            function heatControlInputMin() {
                let v = parseFloat($('txtHeatMin').value);
                if (v && !isNaN(v)) {
                    shipTailHeatMn = v;
                    remapShipTail();
                }
                else {
                    $('txtHeatMin').value = shipTailHeatMn;
                }
                $('heatControlAutoMn').checked = false;
            }
            function heatControlInputMax() {
                let v = parseFloat($('txtHeatMax').value);
                if (v && !isNaN(v)) {
                    shipTailHeatMx = v;
                    remapShipTail();
                }
                else {
                    $('txtHeatMax').value = shipTailHeatMx;
                }
                $('heatControlAutoMx').checked = false;
            }

            function heatControlAdjust(mx, direc) {
                const curmn = parseFloat($('txtHeatMin').value);
                const curmx = parseFloat($('txtHeatMax').value);
                if (!curmn || !curmx) {
                    console.log(curmn + ' ' + curmx);
                    return;
                }
                var diff = (curmx - curmn);
                var incr;
                if (isNaN(diff)) {
                    console.log(diff + ' ' + curmn + ' ' + curmx);
                    return;
                }

                if (diff <= 0.01)
                    incr = 0.05;
                else
                    incr = diff/10;

                var v;
                console.log('diff = ' + diff);
                if (mx)  {
                    v = curmx + direc*incr; 
                    if (v < curmn) v = curmn;
                    $('txtHeatMax').value = v;
                    heatControlInputMax();
                }
                else {
                    v = curmn + direc*incr; 
                    if (v > curmx) v = curmx;
                    $('txtHeatMin').value = v;
                    heatControlInputMin();
                }
            }

            function clearTail(n) {
                if (shipTailGroup == null) 
                    return;

                const marks = shipTailGroup.getLayers();
                if (n == 0) n = marks.length;
                else if (n == -1) n = marks.length / 2;
                
                let m = marks.length;
                console.log('length ' + m);
                for (var i = 0 ; i < n ; i++) {
                    shipTailGroup.removeLayer(marks[i]);
                    map.removeLayer(marks[i]);
                }
                m = shipTailGroup.getLayers().length
                console.log('length ' + m);
            }

            function saveTail() {
                if (shipTailGroup == null) 
                    return;

                const marks = shipTailGroup.getLayers();
                txt = '';
                for (var i = 0 ; i < marks.length ; i++) {
                    lalo = marks[i].getLatLng();
                    lbl  = marks[i].getPopup()._content;
                    txt = txt + lalo.lat + ' ' + lalo.lng + ' ' + lbl;
                    if (marks[i].heat) txt = txt + ' ' + marks[i].heat;
                    txt = txt + '\n';
    
                }
                const fname = 'shiptail_' + (new Date().toISOString().slice(0,-8)) + '.dat';
                download(fname, txt);
            }

            function removeTags(str, tag) {
                const reStr = `<${tag}.*>.*?<\\\/${tag}>`;
                const re = new RegExp(reStr, 'ig');
                if ((str===null) || (str===''))
                    return false;
                else
                    str = str.toString();
                      
                return str.replace(re, '');
            }

            function toggleHamburger() {
                const state = document.getElementById('hamDiv').style.display;
                if (state != 'block') {
                    const btn = hamburgerBtn.getContainer();
                    const rect = btn.getBoundingClientRect();
                    document.getElementById('hamDiv').style.display = 'block';
                    document.getElementById('hamDiv').style.top = rect.top;
                    document.getElementById('hamDiv').style.left = rect.right;
                }
                else {
                    document.getElementById('hamDiv').style.display = 'none';
                }
            }

            function toggleHeatControl() {
                const state = document.getElementById('heatControlDiv').style.display;
                console.log(state);
                if (state != 'block') {
                    const btn = heatControlBtn.getContainer();
                    const rect = btn.getBoundingClientRect();
                    document.getElementById('heatControlDiv').style.display = 'block';
                    document.getElementById('heatControlDiv').style.top = rect.top;
                    document.getElementById('heatControlDiv').style.left = rect.right;
                }
                else {
                    document.getElementById('heatControlDiv').style.display = 'none';
                }
            }

            
            async function fetchWeather(latlng, popup, map) {
                var url1 = "https://marine-api.open-meteo.com/v1/marine?latitude=" + latlng.lat.toFixed(4) + "&longitude=" + latlng.lng.toFixed(4) + "&hourly=wave_height";
                var url2 = "https://api.open-meteo.com/v1/forecast?latitude=" + latlng.lat.toFixed(4) + "&longitude=" + latlng.lng.toFixed(4) + "&hourly=windspeed_10m,pressure_msl,precipitation,visibility";
                var url3 = `../proxy/https://api.opentopodata.org/v1/gebco2020?locations=${latlng.lat.toFixed(4)},${latlng.lng.toFixed(4)}`;
                var url5 = `../proxy/https://marine.weather.gov/MapClick.php?lat=${latlng.lat.toFixed(4)}&lon=${latlng.lng.toFixed(4)}&unit=0&lg=english&FcstType=text&TextType=1`; 
                // Promise.all does bomb if anything bombs - but is faster ...
                let resp = await Promise.all([
                                                fetch(url1).then(response => response.json()),
                                                fetch(url2).then(response => response.json()),
                                                fetch(url3).then(response => response.json()),
                                                fetch(url5).then(response => response.text()),
                                             ]);
                
                let waves = resp[0];
                let wind = resp[1];
                let depth = resp[2];
                let marine = resp[3];
               
                marine = removeTags(marine, 'head');
                marine = removeTags(marine, 'header');
                marine = removeTags(marine, 'nav');
                marine = marine.replaceAll('MapClick.php', 'https://marine.weather.gov/MapClick.php');
                marine = marine.replaceAll('width="800"', '');
                   
                var n = waves['hourly']['time'].length;
                var m = wind['hourly']['time'].length;
                var i;
                var txt = `<a href="https://www.marinetraffic.com/en/ais/home/centerx:${latlng.lng.toFixed(4)}/centery:${latlng.lat.toFixed(4)}/zoom:9" target="_blank">AIS</a> * <a href="https://windy.com?${latlng.lat.toFixed(4)},${latlng.lng.toFixed(4)},8" target="_blank">windy</a><br>`
                // console.log(txt);
                txt = txt + "Forecast for " + formatPos(dd2ddmm(latlng.lat)) + "," + formatPos(dd2ddmm(latlng.lng)) + ',z=' + depth['results'][0]['elevation'] + 'm <table style="text-align:right";>';
                
                txt += '<tr style="text-align:center;"><th>UTC</th><th>wind (m/s)</th><th>SWH (m)</th><th>SLP (mbar)</th><th>precip (mm)</th><th>vis (km)</th></tr>';
                for (i = 0 ; i < n && i < m && i < 72 ; i += 12) {
                    txt += "<tr><td>" + waves['hourly']['time'][i] + "</td>"; 
                    txt += "    <td>" + (parseFloat(wind['hourly']['windspeed_10m'][i])/3.6).toFixed(2) + "</td>";
                    txt += "    <td>" + waves['hourly']['wave_height'][i] + "</td>";
                    txt += "    <td>" + wind['hourly']['pressure_msl'][i] + "</td>";
                    txt += "    <td>" + wind['hourly']['precipitation'][i] + "</td>";
                    txt += "    <td>" + (parseFloat(wind['hourly']['visibility'][i])/1000).toFixed(0.1) + "</td></tr>";
                }
                txt += "</table>";
                txt += "via Open-Meteo and German Weather Service DWD";

                if (mar = marine.includes("NWS Forecast for:")) {
                    var fcast = marine.substring(marine.indexOf("<b>NWS Forecast for:"));
                    var last = fcast.indexOf("<hr><br></td></tr><tr><td colspan");
                    txt += "<br><hr>" + fcast.substring(0,last+18);
                }

                popup.setLatLng(latlng)
                     .setContent(txt)
                     .openOn(map);
            }

            function ttgString(ttg) {
                var str;

                if (ttg < 24) {
                    var hrs = Math.floor(ttg);
                    var min = (ttg - hrs)*60;
                    str = '' + hrs + 'h' + Math.floor(min) + 'm';
                }
                else {
                    var days = Math.floor(ttg/24);
                    var hrs = Math.floor(ttg - days*24);
                    var min = (ttg - days*24 - hrs)*60;
                    str = '' + days + 'd' + hrs + 'h' + Math.floor(min) + 'm';
                } 

                return str;
            }
        
            var saLayers     = [];
            var saTailLayers = [];
            var saAssets     = []; // [ { id: , mark:, time:, tail: [ { mark:, time: } ] } ], 

            function loadSALayer(data, label, i) {
                const types = ["triangle", "circle", "square", "triangle"];
                const colors = ["#ff0000", "#00ff00", "#0000ff", "#ff00ff"];
                var short;
                var html;
                var mk, fnd, ta;
                var t;

                if (saLayers.length <= 0) {
                    saLayers[i] = new L.layerGroup();
                    saTailLayers[i] = new L.layerGroup();
                    layerControl.addOverlay(saLayers[i], label, "overlays"); 
                    layerControl.addOverlay(saTailLayers[i], label + ' tails', "overlays"); 
                    saLayers[i].addTo(map);
                }
                for (d of data) {
                    if (d['id'].length > 8)
                        short = "..." + d['id'].slice(-5);
                    else
                        short = d['id'];

                    html = [
                        d.class + " " + d.id,
                        formatPos(dd2ddmm(d.lat)) + "," + formatPos(dd2ddmm(d.lon)),
                        d.date + " " + d.time,
                        `<span onclick="activateAsset('${short}');">activate</span>`,
                    ].join('<br />');

                    t = Date.parse(d.date + 'T' + d.time + 'Z')/1000;
                    if (tailMinTime == 0 || t < tailMinTime)
                        tailMinTime = t;
                    if (t > tailMaxTime) {
                        tailMaxTime = t;
                        console.log('new max time');
                        if (slider.value == 100) {
                            slider.updateText();
                        }
                    } 
                    mk = null;
                    fnd = saAssets.filter((a) => a.id == short);
                    if (fnd.length > 0)
                        mk = fnd[0]['mark'];

                    if (mk && fnd[0].time != t) {
                        if (d.subcat > 0 || shipTailGroup == null) {
                            if (fnd[0].tail.filter((p) => p.time == t).length == 0) {
                                ta = new L.circleMarker([d.lat, d.lon],
                                               {
                                                    radius: 1,
                                                    color: colors[d.subcat],
                                               })
                                               .bindPopup(html);

                                fnd[0]['tail'].push( { mark: ta, time: t } );
                                ta.addTo(saTailLayers[i]);
                            }
                        }
                        if (t > fnd[0].time) {
                            mk.setLatLng([d.lat, d.lon]);
                            mk.getPopup().setContent(html);
                            fnd[0].time = t;
                        }
                    }
                    else if (mk == null) {
                        mk = L.shapeMarker([d.lat, d.lon], 
                                            {
                                                shape: types[d.subcat],
                                                radius: 5,
                                                color: colors[d.subcat],
                                            }
                                           )
                                            .bindTooltip(short, { permanent: true, className: 'assetLabel' })
                                            .bindPopup(html);

                        saAssets.push( { mark: mk, id: short, tail: [], time: t } );
                        mk.addTo(saLayers[i]);
                    }
                } 
            }


            async function loadSA(map, layerControl, urls, labels) {

                let resp = await Promise.all(urls.map(url => fetch(url).then(resp => resp.json())));
                console.log('loading SA');
                for (var i = 0 ; i < urls.length ; i++) {
                    data = resp[i];

                    loadSALayer(data, labels[i], i);

                }
                setTimeout(function() { loadSA(map, layerControl, urls, labels) }, 300000);
            }

            function loadSAFromFile() {
                var input = document.createElement('input');
                input.type = 'file';

                input.onchange = e => { 

                   // getting a hold of the file reference
                   var file = e.target.files[0]; 

                   // setting up the reader
                   var reader = new FileReader();
                   reader.readAsText(file,'UTF-8');

                   // here we tell the reader what to do when it's done reading...
                   reader.onload = readerEvent => {
                      var content = readerEvent.target.result; // this is the content!
                      const lines = content.split('\n');
                      var k = 0;
                      var d = [];
                      var lat, lon;
 
                      for (var i = 0 ; i < lines.length ; i++) {
                        const pcs = lines[i].split(' ');
                        if (pcs.length == 11) {
                            lat = parseFloat(pcs[4]) + parseFloat(pcs[5])/60;
                            if (pcs[6] == 'S') lat = -lat;
                            lon = parseFloat(pcs[7]) + parseFloat(pcs[8])/60;
                            if (pcs[9] == 'W') lon = -lon;
                            d.push( { class: pcs[0], id: pcs[1], date: pcs[2], time: pcs[3], subcat: parseInt(pcs[10]), lat: lat, lon: lon });
                        }
                      }

                      if (d.length)  {
                        loadSALayer(d, '/missionsa/1', k);
                      }
                   }

                }

                input.click();
            }

            var activeRoute    = null;
            var activeMarkIdx  = -1;
            var activeRouteIdx = -1;
            var activeMk       = null;
            var markerClicked  = false;
            var routesLayer    = null;
            var activeAsset    = null;
            var activeAssetOriginalColor = null;
            var activeAssetOriginalRadius = 5;
            var activeGlider   = null;
            var prev_shipLaLo  = null;
            var gliderMarkers  = Object.create(null);
            var usingLocation  = false;
            var windSpeed = null;
            var windDir = null;
            var windMarker = null;
            var shipMarker = null;
            var shipCenterToggle = null;
            var shipRingsGroup = null;
            var shipRings = null;
            const shipTailIncrement = 10;
            var shipTailCount = 0;
            var shipTailGroup = null;
            var shipTailHeatMx = null;
            var shipTailHeatMn = null;
            var shipTailHeatVal = null;
            var tailMinTime = 0;
            var tailMaxTime = 0;
            var droppedMarks = [];
            var assetMarkers = [];

            function setupLocation() {
                document.getElementById('basicInfo').innerHTML = 'Pos:';
                // document.getElementById('basicInfo').removeEventHandler('click', setupLocation);

                shipMarker = L.shapeMarker([0, 0], 
                                           {
                                                shape: 'arrowhead',
                                                radius: 8,
                                                color: 'black',
                                                rotation: 0
                                           });
                shipMarker.addTo(map);
                layerControl.addOverlay(shipMarker, 'ship', "chart"); 
                document.getElementById('info').style.display = 'block';

                windMarker = L.shapeMarker([0, 0], 
                                           {
                                                shape: 'arrowline',
                                                radius: 5,
                                                color: 'blue',
                                                scale: 3,
                                                rotation: 0
                                           });
                layerControl.addOverlay(windMarker, 'wind', "chart"); 

                usingLocation = true;

                const locID = navigator.geolocation.watchPosition(
                    (position) => {
                        shipMarker.setLatLng([position.coords.latitude, position.coords.longitude]);
                        windMarker.setLatLng([position.coords.latitude, position.coords.longitude]);
                        updateShipRings();
 
                        const shipLaLo = shipMarker.getLatLng();

                        var cog;
                        if ('heading' in position.coords && position.coords.heading && !Number.isNaN(position.coords.heading)) {
                            cog = position.coords.heading;
                        }
                        else if (prev_shipLaLo != null) {
                            cog = bearing({lat: prev_shipLaLo['lat'], lon: prev_shipLaLo['lng']},  
                                          {lat: shipLaLo['lat'], lon: shipLaLo['lng']});
                        }
                        else {
                            cog = 0;
                        }

                        shipMarker.setRotation(cog);

                        prev_shipLaLo = {...shipLaLo};

                        html = [
                          'Pos: ' + formatPos(dd2ddmm(shipLaLo['lat'])) + ',' + formatPos(dd2ddmm(shipLaLo['lng'])), 
                          'COG: ' + cog.toFixed(1) + '&deg;',
                          'SOG: ' + (position.coords.speed/0.514).toFixed(2) + ' kts',
                        ];
                        if (windSpeed && windDir) {
                            html.push('wind: ' + windSpeed.toFixed(1) + ' @ ' + windDir.toFixed(0) + '&deg');
                        }

                        document.getElementById('basicInfo').innerHTML = html.join('<br />');

                        if (activeGlider != null) {
                            const lalo = activeGlider.getLatLng();

                            var dist = haversine({lat: shipLaLo['lat'], lon: shipLaLo['lng']}, {lat: lalo['lat'], lon: lalo['lng']});
                            var brng = bearing({lat: shipLaLo['lat'], lon: shipLaLo['lng']}, {lat: lalo['lat'], lon: lalo['lng']});
                            var html;

                            if (dist < 5000)
                                html = 'Rng: ' + dist.toFixed(0) + ' m';
                            else if (dist < 10000)
                                html = 'Rng: ' + (dist/1852).toFixed(2) + ' nm';
                            else if (dist < 50000)
                                html = 'Rng: ' + (dist/1852).toFixed(1) + ' nm';
                            else
                                html = 'Rng: ' + (dist/1852).toFixed(0) + ' nm';

                            html = html + '&nbsp;&nbsp; Brg: ' + brng.toFixed(1) + '&deg;' ;

                            html = html + '<br />';
                            html = html + 'Pos: ' + formatPos(dd2ddmm(lalo['lat'])) + ',' + formatPos(dd2ddmm(lalo['lng']));
                            document.getElementById('rangeInfo').innerHTML = html;
                        }
                    }, 
                    () => { 
                        console.log('no position'); 
                    },
                    { 
                        enableHighAccuracy: true,
                        maximumAge: 15000,
                        timeout: 12000,
                    }
                );
            }

            function updateRouteInfo(la, lo, sog) {
                const date = new Date();
                var offset = date.getTimezoneOffset()*60000;
                var routeDistToMark;
                var mkLaLo;
                var wpTTG, wpETA;

                if (activeAsset != null || activeGlider != null) {
                    if (activeAsset != null)
                        mkLaLo = activeAsset.getLatLng();
                    else
                        mkLaLo = activeGlider.getLatLng();

                    routeDistToMark = haversine({lat: la, lon: lo}, {lat: mkLaLo.lat, lon: mkLaLo.lng})/1852;
                }
                else if (activeRoute != null) {
                    routeDistToMark = haversine({lat: la, lon: lo}, activeRoute[activeMarkIdx])/1852;
                }

                if (!isNaN(routeDistToMark))
                    wpTTG = routeDistToMark / sog; 
                else
                    wpTTG = 0;

                wpETA = new Date(Date.now() - offset + wpTTG*3600000);

                if (activeRoute != null) {
                    var i;
                    var routeDistToEnd = routeDistToMark;
                    for (i = activeMarkIdx ; i < activeRoute.length - 1 ; i++)
                        routeDistToEnd += haversine(activeRoute[i], activeRoute[i+1])/1852;
                
                    const routeTTG = (routeDistToEnd) / sog;
                    routeETA       = new Date(Date.now() - offset + routeTTG*3600000);
                    
                    html = [
                        'DTM: ' + routeDistToMark.toFixed(1) + ' nm',
                        'TTM: ' + ttgString(wpTTG),
                        'ETA: ' + wpETA.toISOString().slice(0,16) + 'L',
                        'DTE: ' + routeDistToEnd.toFixed(1) + ' nm',
                        'TTE: ' + ttgString(routeTTG),
                        'ETA: ' + routeETA.toISOString().slice(0,16) + 'L',
                    ].join('<br />');
                }
                else {
                    html = [
                        'DTM: ' + routeDistToMark.toFixed(1) + ' nm',
                        'TTM: ' + ttgString(wpTTG),
                        'ETA: ' + wpETA.toISOString().slice(0,16) + 'L'
                    ].join('<br />');
                }
                document.getElementById('routeInfo').innerHTML = html;
            }

            function addShipTailMarker(la, lo, t, hv) {
                var color = 'black';
                var remap = false;

                if (!la || !lo)
                    return false;
 
                let ttext = new Date(t*1000).toISOString().replace('T', ' ').slice(0,-8);
                if (t > tailMaxTime) {
                    tailMaxTime = t;
                    if (slider.value == 100) {
                        slider.updateText();
                    }
                }
                if (tailMinTime == 0 || t < tailMinTime)
                    tailMinTime = t;

                if (hv) {
                    color = colormap('turbo', hv, shipTailHeatMn, shipTailHeatMx);
                    if (shipTailHeatMx == null || (hv > shipTailHeatMx && $('heatControlAutoMx').checked)) {
                        shipTailHeatMx = hv;
                        remap = true;
                    }
                    if (shipTailHeatMn == null || (hv < shipTailHeatMn && $('heatControlAutoMn').checked)) {
                        shipTailHeatMn = hv;
                        remap = true;
                    }
                    ttext = ttext + ' ' + hv;
                }

                var tailMarker = L.circleMarker([la, lo], 
                                           {
                                                radius: hv ? 3 : 1,
                                                fillOpacity: 1,
                                                color: color,
                                           })
                                           .bindPopup(ttext);

                tailMarker.heat = hv;
                tailMarker.t = t;

                if (shipTailGroup == null) {
                    shipTailGroup = L.layerGroup( [ tailMarker ]);
                    shipTailGroup.addTo(map);
                    layerControl.addOverlay(shipTailGroup, 'ship tail', "chart");
                }
                else {
                    tailMarker.addTo(shipTailGroup);
                }

                return remap;
            } 
 
            function setupStream() {
                var loc = window.location, new_uri;
                if (loc.protocol === "https:")
                    new_uri = "wss:";
                else
                    new_uri = "ws:";

                new_uri += "//" + loc.host + '/map/stream';

                var wsocket = new ReconnectingWebSocket(new_uri);
                wsocket.timeoutInterval = 10000;
                wsocket.debug = true;

                console.log('setting up stream');

                wsocket.onerror = function(error) {
                    console.log('stream error detected');
                };

                wsocket.onclose = function(e) {
                    if (e.wasClean) {
                        console.log('stream closed cleanly');
                    }
                    else {
                        console.log('connection died');
                    }
                };

                wsocket.onmessage = function(e) {
                    var msg;
                    var line = e.data;

                    //console.log(line);

                    if (line.startsWith('START')) {
                        console.log('got START ping');
                        return;
                    }

                    try {
                        msg = JSON.parse(line);
                    } catch {
                        console.log('could not parse ws message');
                        return;
                    }

                    // console.log(msg);

                    if ('wind' in msg && windMarker) {
                        windMarker.setRotation(msg['wind'][1] + 180);
                        windMarker.setScale(msg['wind'][0]/30.0*3);
                        windDir = msg['wind'][1];
                        windSpeed = msg['wind'][0];
                    }
                    else if ('ship' in msg && !usingLocation) {
                        var la = ddmm2dd(msg['lat']);
                        var lo = ddmm2dd(msg['lon']);
                        var html;

                        if (shipMarker == null)
                            return;

                        shipMarker.setLatLng([la, lo]);
                        shipMarker.setRotation(msg['hdt']);
                        updateShipRings();
                        if (shipCenterToggle && shipCenterToggle.toggled) {
                            map.panTo([la, lo]);
                        }
                        shipMarker.bringToFront();
                        if (windMarker) {
                            windMarker.setLatLng([la, lo]);
                            windMarker.bringToFront();
                        }

                        html = [
                          'Pos: ' + formatPos(dd2ddmm(la)) + ',' + formatPos(dd2ddmm(lo)), 
                          'COG: ' + msg['cog'].toFixed(1) + '&deg;' + '&nbsp;&nbsp;HDT: ' + msg['hdt'].toFixed(1) + '&deg;',
                          'SOG: ' + msg['sog'].toFixed(2) + ' kts',
                        ];
                        if (windSpeed && windDir) {
                            html.push('wind: ' + windSpeed.toFixed(1) + ' @ ' + windDir.toFixed(0) + '&deg');
                        }
                        document.getElementById('basicInfo').innerHTML = html.join('<br/>');

                        if (activeRoute != null || activeAsset != null || activeGlider != null) {
                            updateRouteInfo(la, lo, msg['sog']);
                        }

                        if (shipTailCount == 0) {
                            if (addShipTailMarker(la, lo, Date.now()/1000, shipTailHeatVal))
                                remapShipTail();

                            shipTailCount = shipTailIncrement;
                        }
                        else {
                            shipTailCount --;
                        } 
                    }
                    else if ('tail' in msg) {
                        shipTailHeatVal = parseFloat(msg['tail'][0]); 
                    }
                    else if ('connected' in msg) {
                        // we don't actually have kml ready yet ...
                        // loadGliderKML(map, layerControl, [ msg['glider'] ], [ msg['mission'] ], -1, null, false, true);
                        var key = msg['glider'] + '_' + (msg['mission'] ? msg['mission'] : '');
                        if (key in gliderMarkers) {
                            gliderMarkers[key].setLatLng([ msg['lat'], msg['lon'] ]);
                        }
                        else {
                            console.log('unknown ' + key);
                        }
                    }
                    else if ('content' in msg && msg['content'] == 'files=all' &&
                             (msg['when'] == 'socket' || msg['when'] == 'sync') ) {

                        var key = msg['glider'] + '_' + (msg['mission'] ? msg['mission'] : '');
                        if (key in gliderKMLlayers) { 
                            loadGliderKML(map, layerControl, [ msg['glider'] ], [ msg['mission'] ? msg['mission'] : '' ], -1, null, false, true);
                        }
                        else {
                            console.log('unknown ' + key);
                        }
                    }

                }
            }

            function setupShip(map, layerControl, shipName, marker) {
            
                if (marker == null) {
                    shipMarker = L.shapeMarker([0, 0], 
                                               {
                                                    shape: 'arrowhead',
                                                    radius: 8,
                                                    color: 'black',
                                                    rotation: 0
                                               });
                    // newLayer = L.layerGroup([ shipMarker ]);
                    // layerControl.addOverlay(newLayer, shipName);
                    // newLayer.addTo(map);
                    shipMarker.addTo(map);
                    layerControl.addOverlay(shipMarker, 'ship', "chart"); 
        
                    windMarker = L.shapeMarker([0, 0], 
                                               {
                                                    shape: 'arrowline',
                                                    radius: 5,
                                                    scale: 3,
                                                    color: 'blue',
                                                    rotation: 0
                                               });
                    layerControl.addOverlay(windMarker, 'wind', "chart"); 
                }
                else {
                    shipMarker = marker;
                }

                document.getElementById('info').style.display = 'block';

                map.on("click", function(e) {
                    if (markerClicked) {
                        markerClicked = false;
                        return;
                    }

                    shipLaLo = shipMarker.getLatLng();
                    lalo = e.latlng;         

                    var dist = haversine({lat: shipLaLo['lat'], lon: shipLaLo['lng']}, {lat: lalo['lat'], lon: lalo['lng']});
                    var brng = bearing(  {lat: shipLaLo['lat'], lon: shipLaLo['lng']}, {lat: lalo['lat'], lon: lalo['lng']});
                    var html;

                    if (dist < 5000)
                        html = 'Rng: ' + dist.toFixed(0) + ' m';
                    else if (dist < 10000)
                        html = 'Rng: ' + (dist/1852).toFixed(2) + ' nm';
                    else if (dist < 50000)
                        html = 'Rng: ' + (dist/1852).toFixed(1) + ' nm';
                    else
                        html = 'Rng: ' + (dist/1852).toFixed(0) + ' nm';

                    html = html + '&nbsp;&nbsp; Brg: ' + brng.toFixed(1) + '&deg;' ;

                    html = html + '<br />';
                    html = html + 'Pos: ' + formatPos(dd2ddmm(lalo['lat'])) + ',' + formatPos(dd2ddmm(lalo['lng']));
                    document.getElementById('rangeInfo').innerHTML = html;
                });

            }

            function setupShipRings(map, layerControl, ranges) {
                var mk;
                
                shipRings = []
                for (var i = 0 ; i < ranges.length ; i++) {
                    mk = L.circle(shipMarker.getLatLng(), { radius: ranges[i], color: 'black', fill: false, weight: 1 });
                    shipRings.push(mk);
                }
                shipRingsGroup = L.layerGroup(shipRings);
                shipRingsGroup.addTo(map);
                layerControl.addOverlay(shipRingsGroup, 'range rings', "chart"); 
            }

            function updateShipRings() {
                if (shipRings && shipRings.length) {
                    for (var i = 0 ; i < shipRings.length ; i++) {
                        shipRings[i].setLatLng(shipMarker.getLatLng());
                    }
                }
            }

            function activateGlider(mk) {
                if (mk.options.hasOwnProperty('id') && mk.options.id == "seagliderPositionHighlightState") {
                    console.log('getting glider from kml icon ' + mk['key']);
                    console.log(mk);
                    if ('key' in mk && mk['key'] in gliderMarkers)
                        mk = gliderMarkers[mk['key']];
                    else
                        mk = null;
                    console.log('now');
                    console.log(mk);
                }
                if (mk == activeGlider) {
                    console.log('deactivating glider');
                    activeGlider = null;
                    document.getElementById('routeInfo').innerHTML = '';
                    return;
                }

                console.log('activating glider');
                activeGlider = mk;
            }

            function activateRoute(mk) {
                console.log('activating route');
                var route = mk['route'];
                var i     = mk['routeIdx'];
                var j     = mk['markIdx'];
                if (i == activeRouteIdx && j == activeMarkIdx) {
                    activeRoute    = null;
                    activeMarkIdx  = -1;
                    activeRouteIdx = -1;
                    activeMk       = null;
                    mk.setStyle({ color: "black", radius: 5 });
                    document.getElementById('routeInfo').innerHTML = '';
                    return;
                }

                if (activeMk != null) {
                    activeMk.setStyle({ color: "black", radius: 5 });
                }    
                else if (activeAsset != null) {
                    activeAsset.setStyle({ color: activeAssetOriginalColor, radius: activeAssetOriginalRadius });
                    activeAsset = null;
                }
                else if (activeGlider != null) {
                    activeGlider = null;
                }

                activeRouteIdx = i;
                activeMarkIdx  = j; 
                activeRoute    = route;
                activeMk       = mk;
                mk.setStyle({ color: "red", radius: 7 });
            }
    
            function activateAsset(id) {
                var mk = null;
                var fnd = assetMarkers.filter((a) => a.id == id);
                if (fnd.length > 0) {
                    mk = fnd[0];
                }
                else {
                    fnd = droppedMarks.filter((a) => a.id == id); 
                    if (fnd.length > 0)
                        mk = fnd[0];
                    else {
                        fnd = saAssets.filter((a) => a.id == id);
                        if (fnd.length > 0)
                            mk = fnd[0]['mark'];
                    }
                }
    
                if (mk == null)
                    return;
 
                console.log('activating asset');
                if (mk == activeAsset) {
                    activeAsset.setStyle({ color: activeAssetOriginalColor, radius: activeAssetOriginalRadius });
                    activeAsset = null;
                    document.getElementById('routeInfo').innerHTML = '';
                    return;
                }
                if (activeMk != null) {
                    activeMk.setStyle({ color: "black", radius: 5 });
                    activeMk = null;
                }    
                else if (activeAsset != null) {
                    activeAsset.setStyle({ color: activeAssetOriginalColor, radius: activeAssetOriginalRadius });
                }
                else if (activeGlider != null) {
                    activeGlider = null;
                }
                activeRoute               = null;
                activeAssetOriginalColor  = mk.options.color;
                activeAssetOriginalRadius = mk.options.radius;
                activeAsset               = mk;
                mk.setStyle({ color: "red", radius: 7 });
            }

            function loadRoutes(map, layerControl, routes, show) {
                var routeMarkers = [];
                var mk;
                console.log('loading routes');
                console.log(routes);
                for (var i = 0 ; i < routes.length ; i++) {
                    for (var j = 0 ; j < routes[i].length ; j++) {
                        mk = L.shapeMarker([ routes[i][j].lat, routes[i][j].lon ],              
                                           {
                                               shape: "square",
                                               radius: 5,
                                               color: "black"
                                           });
                        mk['routeIdx'] = i;
                        mk['markIdx']  = j;
                        mk['route']    = routes[i];

                        mk.on('click', function(e) {
                            markerClicked = true;
                            activateRoute(this);
                        });
                        routeMarkers.push(mk);

                        if (j < routes[i].length - 1) {
                            ln = L.polyline( [ [routes[i][j].lat, routes[i][j].lon],
                                               [routes[i][j+1].lat, routes[i][j+1].lon] ] );
                            ln.setText('> ', { repeat: false, offset: 6, center: true, attributes: { 'font-weight': 'bold', 'font-size': '18' }});
                            routeMarkers.push(ln);
                        }

                    }
                } 

                if (routesLayer != null) { 
                    layerControl.removeLayer(routesLayer);
                    map.removeLayer(routesLayer);
                }

                routesLayer = L.layerGroup(routeMarkers);
                if (show) routesLayer.addTo(map); 
                layerControl.addOverlay(routesLayer, 'routes', 'assets')
            }
 
            function loadAssets(map, layerControl, assets, glider, mission) {
                var mk;
                console.log(assets);

                for (var i = 0 ; i < assets.length ; i++) {
                    a = assets[i];
                    var newLayer;
                    var html;
                    mk = null; 
                    if (a.type == 'fixed') {
                        console.log('adding fixed ' + a.asset);
                        html = [ a.asset, formatPos(dd2ddmm(a.lat)) + "," + formatPos(dd2ddmm(a.lon)), 
                                 `<span onclick="activateAsset('${a.id}');">activate</span>` ].join('<br/>');
                        try {
                            mk = new L.shapeMarker([a.lat, a.lon],
                                               {
                                                  shape: a.marker,
                                                  radius: 5,
                                                  color: a.color,
                                               }
                                              ).bindTooltip(a.asset, { permanent: true, className: 'assetLabel' })
                                               .bindPopup(html);
                            assetMarkers.push(mk); 
                            mk.id = a.asset;
                            //mk.on('click', function(e) {
                            //    activateAsset(this); 
                            //});
                            layerControl.addOverlay(mk, a.asset, "assets");
                            mk.addTo(map);
                        }
                        catch(e) {
                            console.log('assets ' + e);
                        }
                    }

                    else if (a.type == 'polygon' && 'points' in a) {
                        console.log('adding polygon ' + a.asset);
                        var pts = [];
                        for (var j = 0 ; j < a.points.length ; j++) {
                            pts.push([a.points[j].lat, a.points[j].lon]);
                        }
                        mk = L.polygon(pts, { color: 'color' in a ? a.color : 'green', });
                        mk.bindTooltip(a.asset, { permanent: false, className: 'assetLabel' } );
                        assetMarkers.push(mk);
                        layerControl.addOverlay(mk, a.asset, "assets");
                        mk.addTo(map);
                    }
                    else if (a.type == 'circle' && 'center' in a && 'radius' in a) {
                        console.log('adding circle ' + a.asset);
                        mk = L.circle([a.center.lat, a.center.lon], { radius: a.radius, color: 'color' in a ? a.color : 'green' });
                        mk.bindTooltip(a.asset, { permanent: false, className: 'assetLabel' } );

                        assetMarkers.push(mk);
                        layerControl.addOverlay(mk, a.asset, "assets");
                        mk.addTo(map);
                    }
                    else if (a.type == 'iabp' && 'bid' in a) {
                        console.log('adding iabp ' + a.asset);
                        var url, i, j;
                        if ('tail' in a)
                            url = '../iabp/' + a.bid + '?tail=' + a.tail;
                        else
                            url = '../iabp/' + a.bid;

                        var mks = [];
                
                        (() => { // need to get a into local scope (aa) for async fetch

                            let aa = a;

                            fetch(url)
                            .then(resp => resp.json())
                            .then(d => {
                                p = d[d.length - 1];
                                    
                                html = [ aa.asset, formatPos(dd2ddmm(p['lat'])) + "," + formatPos(dd2ddmm(p['lon'])), "@" + new Date(p['t']*1000).toISOString()]
                                if ('BP' in p)
                                    html.push('BP=' + p['BP']);
                                if ('Ta' in p)
                                    html.push('Ta=' + p['Ta']);

                                html.push(`<span onclick="activateAsset('${aa.asset}');">activate</span>`);
                                html = html.join('<br/>');
                                try {
                                    mk = new L.shapeMarker([p['lat'], p['lon']],
                                                       {
                                                          shape: aa.marker,
                                                          radius: 5,
                                                          color: aa.color,
                                                       }
                                                      ).bindTooltip(aa.asset, { permanent: true, className: 'assetLabel' })
                                                       .bindPopup(html);
                                    assetMarkers.push(mk); 
                                    mk.id = aa.asset;
                                    //mk.on('click', function(e) {
                                    //    activateAsset(this.id); 
                                    //});
                                    mks.push(mk); 
                                    //layerControl.addOverlay(mk, aa.asset, "assets");
                                    //mk.addTo(map);
                                }
                                catch(e) {
                                    console.log('assets ' + e);
                                    console.log(d);
                                }

                                if (aa.tail && parseInt(aa.tail) > 0) {
                                    var i, j, ntail = parseInt(aa.tail);
                                    if (ntail > d.length - 1) {
                                        ntail = d.length - 1;
                                    }
                                    for (i = 0, j = d.length - 2 ; i < ntail ; i++, j--) {
                                        mk = new L.shapeMarker([ d[j]['lat'], d[j]['lon'] ],
                                                           {
                                                              shape: aa.marker,
                                                              radius: 2,
                                                              color: aa.color,
                                                           });
                                        mks.push(mk);
                                    }
                                    
                                }

                                var newL = L.layerGroup(mks);
                                layerControl.addOverlay(newL, aa.asset, "assets");
                                newL.addTo(map);
                            });

                        })();
                    }
                    else if (glider > 0 && a.type == 'csv' && 'file' in a) {
                        console.log('adding csv ' + a.asset);
                        var url, i, j;
                        if (mission == null || mission == undefined || mission == '') 
                            url = '../csv/' + glider + '?file=' + a.file;
                        else
                            url = '../csv/' + glider + '?mission=' + mission + '&file=' + a.file;

                        var mks = [];
                
                        (() => { // need to get a into local scope (aa) for async fetch

                            let aa = a;

                            fetch(url)
                            .then(resp => resp.json())
                            .then(d => {
                                if ('data' in d) {
                                    p = d['data'][d['data'].length - 1];
                                        
                                    html = [ aa.asset, formatPos(dd2ddmm(p[2])) + "," + formatPos(dd2ddmm(p[1])), "@" + new Date(p[0]*1000).toISOString(),
                                            `<span onclick="activateAsset('${a.id}');">activate</span>` ].join('<br/>');
                                    try {
                                        mk = new L.shapeMarker([p[2], p[1]],
                                                           {
                                                              shape: aa.marker,
                                                              radius: 5,
                                                              color: aa.color,
                                                           }
                                                          ).bindTooltip(aa.asset, { permanent: true, className: 'assetLabel' })
                                                           .bindPopup(html);
                                        assetMarkers.push(mk); 
                                        mk.id = aa.asset;
                                        //mk.on('click', function(e) {
                                        //    activateAsset(this.id); 
                                        //});
                                        
                                        mks.push(mk); 
                                        //layerControl.addOverlay(mk, aa.asset, "assets");
                                        //mk.addTo(map);
                                    }
                                    catch(e) {
                                        console.log('assets ' + e);
                                        console.log(d);
                                    }

                                    if (aa.tail && parseInt(aa.tail) > 0) {
                                        var i, j, ntail = parseInt(aa.tail);
                                        if (ntail > d['data'].length - 1) {
                                            ntail = d['data'].length - 1;
                                        }
                                        for (i = 0, j = d['data'].length - 2 ; i < ntail ; i++, j--) {
                                            mk = new L.shapeMarker([d['data'][j][2], d['data'][j][1]],
                                                               {
                                                                  shape: aa.marker,
                                                                  radius: 2,
                                                                  color: aa.color,
                                                               });
                                            mks.push(mk);
                                        }
                                        
                                    }

                                    var newL = L.layerGroup(mks);
                                    layerControl.addOverlay(newL, aa.asset, "assets");
                                    newL.addTo(map);
                                }
                                else {
                                    console.log('missing data');
                                }
                            });

                        })();
                    }
                    else if (a.type == 'json' && 'url' in a) {
                        console.log('adding json ' + a.asset);

                        var obj;
                        if ('method' in a)
                            method = a['method'];
                        else
                            method = 'GET';

                        if (method == 'POST' && 'payload' in a) {
                            obj = a['payload'];
                        }

                        (() => { // need to get a into local scope so it's correct when we async get to the fetch result

                            let aa = a;

                            fetch(aa.url,  {
                                              method: method,
                                              body: JSON.stringify(obj),
                                          })
                            .then(resp => resp.json())
                            .then(d => {
                                console.log(aa);
                                if ('lat' in d && 'lon' in d) {
                                    html = [ aa.asset, formatPos(dd2ddmm(d.lat)) + "," + formatPos(dd2ddmm(d.lon)),
                                            `<span onclick="activateAsset('${aa.asset}');">activate</span>` ].join('<br/>');
                                    if ('sog' in d && 'cog' in d) {
                                        html = html + '<br/>' + d.sog + " @ " + d.cog;
                                    }
                                    mk = new L.shapeMarker([d.lat, d.lon],
                                                       {
                                                          shape: aa.marker,
                                                          radius: 5,
                                                          color: aa.color,
                                                       }
                                                      ).bindTooltip(aa.asset, { permanent: true, className: 'assetLabel' })
                                                       .bindPopup(html);
                                    assetMarkers.push(mk); 
                                    layerControl.addOverlay(mk, aa.asset, "assets");
                                    mk.addTo(map);
                                    mk.id = aa.asset;
                                    //mk.on('click', function(e) {
                                    //    activateAsset(this.id); 
                                    //});
                                    // setupShip(map, layerControl, aa.asset, mk);

                                    if ('interval' in aa && aa.interval > 0) {

                                        setInterval(function() {
                                                        fetch(aa.url, {
                                                            method: method,
                                                            body: JSON.stringify(obj),
                                                        })
                                                        .then(resp => resp.json())
                                                        .then(d => {
                                                            html = [ aa.asset, formatPos(dd2ddmm(d.lat)) + "," + formatPos(dd2ddmm(d.lon))].join('<br/>');
                                                            if ('sog' in d && 'cog' in d) { 
                                                                html = html + '<br/>' + d.sog + " @ " + d.cog;
                                                            }
                                                            mk.setPopupContent(html);
                                                            mk.setLatLng([d.lat, d.lon]);
                                                            if (activeRoute != null || activeAsset != null || activeGlider != null) {
                                                                updateRouteInfo(d.lat, d.lon, d.sog);
                                                            }

                                                            html = [
                                                              'Pos: ' + formatPos(dd2ddmm(d.lat)) + ',' + formatPos(dd2ddmm(d.lon)), 
                                                              'COG: ' + d.cog.toFixed(1) + '&deg;' + '&nbsp;&nbsp;HDT: ' + d.heading.toFixed(1) + '&deg;',
                                                              'SOG: ' + d.sog.toFixed(2) + ' kts',
                                                            ].join('<br />');
                                                            document.getElementById('basicInfo').innerHTML = html;

                                                        })
                                                    }, aa.interval*1000);

                                    }
                                }
                            });
                        })();
                    }
                }
/*
                try {
                    newLayer = L.layerGroup(assetMarkers);
                    layerControl.addOverlay(newLayer, 'assets')
                    newLayer.addTo(map);
                }
                catch(e) {
                    console.log('assets map ' + e);
                }
*/
                for (var i = 0 ; i < assets.length ; i++) {
                    a = assets[i];
                    var newLayer = null;
                    
                    if (a.type == 'tileset') {
                        var minZoom = 'minZoom' in a ? a.minZoom : 3;
                        var maxZoom = 'maxZoom' in a ? a.maxZoom : 16;

                        console.log('adding ' + a.asset);

                        if ('path' in a)
                            newLayer = L.tileLayer('../tile/asset/' + a.path + '/{z}/{x}/{y}', 
                                                   {tms: true, opacity: 0.7, attribution: "", minZoom: minZoom, maxZoom: maxZoom});
                        else if ('url' in a)
                            newLayer = L.tileLayer(a.url, 
                                                   {tms: true, opacity: 0.7, attribution: "", minZoom: minZoom, maxZoom: maxZoom});
            
                        if (newLayer)
                            layerControl.addOverlay(newLayer, a.asset, 'imagery');
                    }
                    else if (a.type == 'image' && 'extents' in a) {
                        console.log('adding ' + a.asset);
                        var bounds = [ [ a.extents[0], a.extents[1] ], [ a.extents[2], a.extents[3] ] ];
                        var url;
                        if ('file' in a && 'format' in a && glider > 0) {
                            url = `../image/${glider}/${a.file}/${a.format}`;
                        }
                        else if ('url' in a) {
                            url = a.url;
                        } 
                        newLayer = L.imageOverlay(a.url, bounds);
                        if (newLayer)
                            layerControl.addOverlay(newLayer, a.asset, 'imagery');
                    }
                }
                
            }

            function loadAlso(map, layerControl, also, tail, glider, mission) {
                var pcs;
                var gliders = [];
                var missions = [];
                var assets = [];
                console.log(also);
                for (var i = 0 ; i < also.length ; i++)  {
                    if ('glider' in also[i]) {
                        missions.push(also[i].mission);
                        if (also[i].glider instanceof Array) {
                            for (var j = 0 ; j < also[i].glider.length ; j++) {
                                gliders.push(also[i].glider[j]);
                                loadGliderPosition(map, layerControl, also[i].glider[j], also[i].mission);
                            }
                        }
                        else {
                            gliders.push(also[i].glider);
                            loadGliderPosition(map, layerControl, also[i].glider, also[i].mission);
                        }
                    }
                    else if ('asset' in also[i]) {
                        assets.push(also[i]); 
                    } 
                    
                }

                console.log(assets);

                if (assets.length) {
                    loadAssets(map, layerControl, assets, glider, mission);
                }
                if (gliders.length)
                    loadGliderKML(map, layerControl, gliders, missions, tail, null, false, false);
            }

                 
            function loadExtras(map, layerControl, glider, mission, tail) {
                var url;

                if (glider !== null) {
                    if (mission && mission != '')
                       url = `../mapdata/${glider}?mission=${mission}`;
                    else
                       url = `../mapdata/${glider}`;
                }
                else {
                    url = '../mapdata';
                }

                fetch(url)
                .then(resp => resp.text()) 
                .then(data => {
                    try {
                        d = JSON.parse(data);
                    } catch {
                        console.log('could not parse extras');
                        return;
                    }
                     
                    console.log(d);
                    if ('kml' in d && d.kml) {
                        console.log('loading KML');
                        loadKML(map, layerControl, d.kml, d.kml);
                    }   
                    if ('sa' in d && d.sa) {
                        console.log('loading SA');
                        var labels = [];
                        for (var i = 0 ; i < d.sa.length ; i++)
                            if (d.sa[i].length > 18)
                                labels.push("..." + d.sa[i].slice(-15));
                            else
                                labels.push(d.sa[i]);

                        loadSA(map, layerControl, d.sa, labels);
                    }
                    // if glider is specified then also has a list of assets
                    // and additional gliders
                    if ('also' in d && d.also) {
                        loadAlso(map, layerControl, d.also, tail, glider, mission);
                    }
                    // if glider is not specified then the response has a list of all assets 
                    // in the yml file
                    else if ('assets' in d && d.assets) {
                        loadAssets(map, layerControl, d.assets, glider, mission);
                    }
                    if ('routes' in d) {
                        loadRoutes(map, layerControl, d.routes, false);
                    }
                })
                .catch(e => {
                    console.log('extras ' + e);
                });
            }
            function loadGliderDAC(map, layerControl, glider, mission) {
                var url; 
        
                if (mission && mission != '')
                    url = `../query/${glider}/dive,avg_latitude,avg_longitude,depth_avg_curr_north,depth_avg_curr_east?mission=${mission}`;
                else
                    url = `../query/${glider}/dive,avg_latitude,avg_longitude,depth_avg_curr_north,depth_avg_curr_east`;

                fetch(url)
                .then(resp => resp.json()) 
                .then(d => {
                    var v = [];
                    var line; 
                    for (var i = 0 ; i < d.dive.length ; i++) {
                        [m,dir] = xy2magdir(d.depth_avg_curr_east[i], d.depth_avg_curr_north[i]);
                        [elat, elon] = reckon([d.avg_latitude[i], d.avg_longitude[i]], 20000*m, dir);                        
                        line = L.polyline([[d.avg_latitude[i], d.avg_longitude[i]], [elat, elon]], {});
                        line.bindTooltip(`dive ${d.dive[i]}<br>${m.toFixed(3)}@${dir.toFixed(1)}&deg;`, {});
                        v.push(line);
                    }
                    let newLayer = L.layerGroup(v);
                    if (mission && mission != '') {
                        layerControl.addOverlay(newLayer, 'DAC', `${glider} ${mission}`); 
                    }
                    else {
                        layerControl.addOverlay(newLayer, 'DAC', `${glider} `); 
                    }

		            if (checkLayerState("DAC", "on"))
                        newLayer.addTo(map); // not by default
                })
                .catch(e => {
                    console.log('DAC ' + e);
                });
            }

            async function loadKML(map, layerControl, urls, names) {
                var kml;
                var parser; 

                try {
                    let resp = await Promise.all(urls.map(url => fetch(url).then(res => res.text())));
                    for (var i = 0 ; i < urls.length ; i++) {
                        console.log('adding KML: ' + urls[i]);
                        kmltext = resp[i];
                        parser = new DOMParser();
                        kml = parser.parseFromString(kmltext, 'text/xml');
                        ly = new L.KML(kml, { });
                        layerControl.addOverlay(ly, names[i], "overlays"); 
                    }
                }
                catch(e) {
                    console.log('loadKML ' + e);
                }
            }

            var gliderKMLlayers = {};
            function removeGliderKMLlayer(map, layerControl, glider, mission) {
                var k;
                var track;
                var key = glider + '_' + mission;
                console.log('maybe removing: ' + key);
                if (key in gliderKMLlayers && gliderKMLlayers[key] != null) {
                    track = gliderKMLlayers[key];
                    console.log('removing ' + key);
                    for (k of Object.keys(track._layers)) {
                        if (track._layers[k].options.hasOwnProperty('name') 
                            && (track._layers[k].options.name.includes('Dives') || track._layers[k].options.name.includes('Targets') || track._layers[k].options.name.includes('SSH'))) {
                            if (track._layers[k].options.name.includes('SSH') && track._layers[k].hasOwnProperty('_layers')) {
                                for (var i = 0 ; i < track._layers[k]._layers.length ; i++) {
                                    layerControl.removeLayer(track._layers[k]._layers[i]);
                                }
                               //  layerControl.removeLayer(track._layers[k]._layers[1]);
                            }
                            layerControl.removeLayer(track._layers[k]);
                        }
                    }

                    map.removeLayer(track);
                    gliderKMLlayers[key] = null; // .track = null; 
                }
                else {
                    if (key in gliderKMLlayers) 
                        console.log('previous layer was null');
                    else {
                        console.log(key + ' not in layers');
                        console.log(gliderKMLlayers);
                    } 
                }
            }
                    
                            
            async function loadGliderPosition(map, layerControl, glider, mission)  {
                var url = '../pos/poll/' + glider;
                if (mission && mission != '')
                    url = url + '?mission=' + mission;
                else
                    mission = '';

                var key = glider + '_' + mission;
                console.log('key = ' + key);
                fetch(url)
                .then(resp => resp.json()) 
                .then(d => {
                    if ('error' in d) {
                        console.log('glider ' + glider + ' ' + d['error']);
                        return;
                    }

                    if (key in gliderMarkers) {
                        gliderMarkers[key].setLatLng([ d['lat'], d['lon'] ]);
                    }
                    else {
                        gliderMarkers[key] = L.shapeMarker([d.lat, d.lon],
                                                           {
                                                              shape: 'diamond',
                                                              radius: 5,
                                                              color: 'yellow',
                                                              zIndexOffset: 100,
                                                           }
                                                          ).addTo(map);

                        layerControl.addOverlay(gliderMarkers[key], 'position', '' + glider + ' ' + mission);
                        gliderMarkers[key].bringToFront();
                        gliderMarkers[key]['key'] = key;
                        gliderMarkers[key].on('click', function(e) {
                            console.log('glider marker native click');
                            markerClicked = true;
                            activateGlider(this);
                        });
                        // gliderMarkers[key].bindPopup((p) => { markerClicked = true; activateGlider(p); return key });
                    }
                }); 
            }
            async function loadGliderKML(map, layerControl, gliders, missions, tail, lastBounds, doCtr, leaveFirst) {
                var kml;
                var parser;
                var i;

                var urls = [];
                for (i = 0 ; i < gliders.length ; i++) {                
                    if (missions[i] == null || missions[i] == undefined || missions[i] == '') {
                        urls.push('../kml/' + gliders[i]);
                        missions[i] = '';
                    }
                    else
                        urls.push('../kml/' + gliders[i] + '?mission=' + missions[i]);

                    if (!((gliders[i] + '_' + missions[i]) in gliderKMLlayers)) {
                        console.log('initializing layer ' + gliders[i] + '_' + missions[i]);
                        gliderKMLlayers[ gliders[i] + '_' + missions[i] ] = null;
                    }
                }
                console.log('loading glider KML layers');
                console.log(urls);
                let resp = await Promise.all(urls.map(url => fetch(url).then(res => res.text())));
                for (i = 0 ; i < urls.length ; i++) {
                    kmltext = resp[i]; 

                    // Create new kml overlay
                    parser = new DOMParser();
                    kml = parser.parseFromString(kmltext, 'text/xml');
                    let ctr = null;
                    track = new L.KML(kml, {
                                                iconOptions: {
                                                    iconSize: [16,16],
                                                }
                                           });

                    // delete any existing track (in case this is a reload of this glider/mission)
                    removeGliderKMLlayer(map, layerControl, gliders[i], missions[i]);

                    map.addLayer(track);
                    gliderKMLlayers[gliders[i] + '_' + missions[i]] = track;
                    console.log('added layer: ' +gliders[i] + '_' + missions[i]);
                    // layerControl.addOverlay(track, "KML"); // If we add controls for the dives and targets layers
                                                              // then this "KML" control only turns off the glider.
                                                              // If we don't add controls for dives and targets
                                                              // then the "KML" control works as expected

                    for (k of Object.keys(track._layers)) {
                        if (track._layers[k].options.hasOwnProperty('id') && track._layers[k].options.id == "seagliderPositionHighlightState") {
                            ctr = track._layers[k]._latlng;
                            layerControl.addOverlay(track._layers[k], 'KML position', '' + gliders[i] + ' ' + missions[i]);
                            track._layers[k]['key'] = gliders[i] + '_' + missions[i];
                            track._layers[k].on('click', function(e) {
                                console.log('glider marker KML click');
                                markerClicked = true;
                                activateGlider(this);
                            });
                        }
                        if (track._layers[k].options.hasOwnProperty('name')
                            && (track._layers[k].options.name.includes('Dives') || track._layers[k].options.name.includes('Targets') || track._layers[k].options.name.includes('SSH') || track._layers[k].options.name.includes('layer_') )) {
                            if (track._layers[k].options.name.includes('Dives')) {
                                layerControl.addOverlay(track._layers[k], 'dives', '' + gliders[i] + ' ' + missions[i]);
                                if (i > 0 || !leaveFirst) map.removeLayer(track._layers[k]);
                            }
                            else if (track._layers[k].options.name.includes('Targets')) {
                                layerControl.addOverlay(track._layers[k], 'targets', gliders[i] + ' ' + missions[i]);
                                if (!Object.keys(localStorage).includes('layerStatus_targets') || localStorage.getItem('layerStatus_targets') == 'off') {

                                    map.removeLayer(track._layers[k]);
                                    console.log("targets " + localStorage['layerStatus_targets']);
                
                                //   console.log("removing targets");
				                }
                                //else {
                                //    console.log("targets " + localStorage['layerStatus_targets']);
                               // }
                            }
                            else if (track._layers[k].options.name.includes('layer_')) {
                                var [dm, ...nm] = track._layers[k].options.name.split('_')
                                layerControl.addOverlay(track._layers[k], nm.join('_'), gliders[i] + ' ' + missions[i]);
                                map.removeLayer(track._layers[k]);
                            }
                            else {
                                var kk;
                                for (kk in track._layers[k]._layers) {
                                    console.log(track._layers[k]._layers[kk]);
                                    layerControl.addOverlay(track._layers[k]._layers[kk], track._layers[k]._layers[kk].options.name, gliders[i] + ' ' + missions[i]);
                                    map.removeLayer(track._layers[k]._layers[kk]);
                                }
                            }
                            // console.log(track._layers[k].options.name);
                            // console.log(missions[i]);
                        }

                        if (tail > -1 && track._layers[k].options.hasOwnProperty('name')
                            && track._layers[k].options.name.includes('Dives')) {
                            console.log('looking for dive layers');
                            var dv, mx = -1;
                            track._layers[k].eachLayer(function(layer) {
                                if (layer.hasOwnProperty('layerID') && layer.layerID.startsWith(`SG${gliders[i]} dive `)) {
                                    dv = parseInt(layer.layerID.split(' ')[2]);
                                    if (dv > mx)
                                        mx = dv; 
                                }
                            });
                            console.log('latest dive is ' + mx);

                            track._layers[k].eachLayer(function(layer) {
                                if (layer.hasOwnProperty('layerID') && layer.layerID.startsWith(`SG${gliders[i]} dive `)) {
                                    dv = parseInt(layer.layerID.split(' ')[2]);
                                    if (dv < mx - tail) {
                                        track._layers[k].removeLayer(layer);
                                    }
                                }
                            });

                        }

                            
                    }

                    // Adjust map to show the kml for the first glider
                    if (i == 0 && doCtr) {
                        if (lastBounds && lastBounds[0] > -180 && lastBounds[1] > -90 && lastBounds[2] < 180 && lastBounds[3] < 90) {
                            map.fitBounds(lastBounds);
                        }
                        else {
                            const bounds = track.getBounds();
                            map.fitBounds(bounds);
                            if (ctr) map.panTo(ctr);
                        }
                    }
                }

                console.log('keys');
                console.log(Object.keys(gliderMarkers));
                for (k of Object.keys(gliderMarkers))  {
                    console.log('bringing ' + k + ' to front');
                    gliderMarkers[k].bringToFront();
                }
            }

            function findGoto(goto, list) {
                for (var i = 0 ; i < list.length ; i++) {
                    if (list[i]['name'] == goto) {
                        return list[i];
                    }
                }
                return null;
            }
            function getTargetsFromVis(data) {
                var k, j, ln, mk, mks = [];
                for (var i = 0 ; i < data.length ; i++) {
                    k = data[i];

                    mk = L.circle([ddmm2dd(k.lat), ddmm2dd(k.lon)], { radius: k.radius, color: 'red' });
                    mk.bindTooltip(k.name, { permanent: false, className: 'assetLabel' } );

                    mks.push(mk);

                    if ('goto' in k && (j = findGoto(k['goto'], data))) {
                        ln = L.polyline( [ [ddmm2dd(k.lat), ddmm2dd(k.lon)],
                                           [ddmm2dd(j.lat), ddmm2dd(j.lon)] ] );
                        ln.setText('> ', { repeat: false, offset: 6, center: true, attributes: { 'font-weight': 'bold', 'font-size': '18' }});
                        mks.push(ln);
                    }
                }
                var newLayer = L.layerGroup(mks);
                layerControl.addOverlay(newLayer, 'vis-targets', glider + ' ' + currMission);
                newLayer.addTo(map);
            }

            function exportTargets(points, fmt) {
                var buffText = "";
                if (fmt == 116 || fmt == 84) { // 't' = targets
                    for(var i = 1; i <= points.length ; i++) {
                        latA = points[i-1].lat;
                        lonA = points[i-1].lng;
                        buffText += i + ' lat=' +  dd2ddmm(latA).toFixed(3) + ' lon=' + dd2ddmm(lonA).toFixed(3) + ' radius=2000 goto=' + (i < points.length ? i+1 : i) + '\n';
                    }
                }
                else if (fmt == 109 || fmt == 77) { // 'm' = marks
                    for(var i = 0; i < points.length ; i++) {
                        latA = points[i].lat;
                        lonA = points[i].lng;
                        buffText += (i+1) + ': {type: fixed, lat: ' +  latA.toFixed(4) + ', lon: ' + lonA.toFixed(4) + ' }\n';
                    }
                }
                else if (fmt == 114 || fmt == 82) { // 'r' = route
                    var pts = [];
                    for(var i = 0; i < points.length ; i++) {
                        pts.push( { lat: points[i].lat, lon: points[i].lng } );
                    }
                    loadRoutes(map, layerControl, [ pts ], true);
/*
                    buffText += '  - [ ';
                    for(var i = 0; i < points.length ; i++) {
                        latA = points[i].lat;
                        lonA = points[i].lng;
                        buffText += '{lat: ' +  latA.toFixed(4) + ', lon: ' + lonA.toFixed(4) + ' }';
                        if (i < points.length - 1)
                            buffText += ',\n      ';
                        else
                            buffText += ' ]\n';
                    }
*/
                }
    
                if (targetsChannel) {
                    targetsChannel.postMessage(points);
                }

                return buffText;
            }

            function saveBounds() {
                var bounds = map.getBounds().toBBoxString();
                localStorage.setItem('latest', bounds);
                localStorage.setItem('' + glider, bounds);
            }

            function loadBounds(which) {
                let x = localStorage.getItem(which);
                if (x) {
                    [west, south, east, north] = x.split(',').map(parseFloat);
                    let bounds = new L.LatLngBounds(new L.LatLng(south, west), new L.LatLng(north, east));
                    return bounds;
                }
                else {
                    return null;
                }
                
            }

            function checkLayerState(which, compare) {
                const items = { ...localStorage }; 
                for (k in items) {
                    if (k == 'layerStatus_' + which) {
                        console.log('found ' + k);
                        console.log(localStorage[k]);
                        console.log('compare = ' + compare);
                        return localStorage[k] == compare;
                    }
                }    

                return false;
            }

            function sliderUpdateTime(v) {
                t = (100 - v)/100.0*(tailMaxTime - tailMinTime) + tailMinTime;
                return new Date(t*1000).toISOString().replace('T', ' ').slice(0,-8);
            }

            function sliderUpdateDisplay(v) {
                t = (100-v)/100.0*(tailMaxTime - tailMinTime) + tailMinTime;
                // var saAssets     = []; // [ { id: , mark:, time:, tail: [ { mark:, time: } ] } ], 
                for (var a of saAssets) {
                    if ('tail' in a && a.tail.length > 0) {
                        for (var tl of a.tail) {
                            if (map.hasLayer(tl.mark) && tl.time <= t)
                                map.removeLayer(tl.mark); 
                            else if (map.hasLayer(tl.mark) == false && tl.time >= t)
                                tl.mark.addTo(map);
                        }
                    }     
                }

                if (shipTailGroup == null)
                    return;

                const marks = shipTailGroup.getLayers();
                for (var i = 0 ; i < marks.length ; i++) {
                    if (map.hasLayer(marks[i]) && marks[i].t <= t) {
                        map.removeLayer(marks[i]);
                    }
                    else if (map.hasLayer(marks[i]) == false && marks[i].t >= t)
                        marks[i].addTo(map);
                }
            }
    
            function deleteMark(id) {
                let fnd = droppedMarks.filter((a) => a.id == id);
                if (fnd.length > 0)
                    m = fnd[0];
                map.removeLayer(m);
            }

            function draggableMarker(map, m) {
                function drag(e) {
                    let html = [
                        formatPos(dd2ddmm(e.latlng.lat)) + "," + formatPos(dd2ddmm(e.latlng.lng)),
                        `<span onclick="deleteMark('${m.id}');">delete</span> <span onclick="activateAsset('${m.id}');">activate</span>`
                    ].join('<br />');

                    m.setLatLng(e.latlng);
                    m.getPopup().setContent(html);
                }

                m.on("mousedown", () => {
                    map.dragging.disable();
                    map.on("mousemove", drag);
                });

               m.on("mouseup", () => {
                    map.dragging.enable();
                     map.off("mousemove", drag);
                });
            }
/*
            var setupHandler = function(e) {
                setupLocation(map, layerControl);
                document.getElementById('basicInfo').innerHTML = 'Pos:');
                document.getElementById('basicInfo').removeEventListener('click', setupHandler);
            };
*/ 
        </script>

        <script type="text/javascript">


            let params = new URLSearchParams(window.location.search);

            // Make basemap
            const map = new L.Map('map', { center: new L.LatLng(47.5, -122.3), zoom: 11 });
            let last = loadBounds('latest');
            if (last)
                map.fitBounds(last);

            const osm = new L.TileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { opacity: 1.0 });
            const noaa = new L.TileLayer('https://iop.apl.washington.edu/tiles/NOAA+Stamen/{z}/{x}/{y}.png');
            // const noaa = new L.TileLayer('../tile/NOAA+Stamen/{z}/{x}/{y}');


            // gebco = L.tileLayer.wms("https://www.gebco.net/data_and_products/gebco_web_services/web_map_service/mapserv?",
            gebco = L.tileLayer.wms("https://wms.gebco.net/2024/mapserv?",
                                    {
                                        layers:"GEBCO_2024",
                                        format:"image/png",
                                        opacity: 0.4,
                                    });
                           
            if (checkLayerState("GEBCO shading", "on"))
                map.addLayer(gebco); 


            eez = L.tileLayer.wms("https://geo.vliz.be/geoserver/gwc/service/wms?",
                                    {
                                        layers: 'MarineRegions:eez_boundaries',
                                        format: "image/png",
                                        transparent: "true",
                                        // opacity: 0.2
                                    });

            if (checkLayerState("EEZ", "on"))
                map.addLayer(eez); 

            console.log(Object.keys(localStorage));
            console.log(Object.keys(localStorage).includes("baseLayer"));
            console.log(localStorage.getItem('baseLayer'));

            if (Object.keys(localStorage).includes('baseLayer') && localStorage.getItem('baseLayer') == "NOAA+Stamen")
                map.addLayer(noaa);
            else
                map.addLayer(osm);
            
            // AIS
            

            ais = L.tileLayer.wms("https://gmtds.maplarge.com/ogc/ais:density/wms?",
                                    {
                                        layers: 'ais:density',
                                        format: 'image/png',
                                        opacity: 0.4,
                                    });

            //ais = L.tileLayer("https://tiles.marinetraffic.com/ais_helpers/shiptilesingle.aspx?output=png&sat=1&grouping=shiptype&tile_size=512&legends=1&zoom={z}&X={x}&Y={y}",
            //                        {
            //                            tileSize: 512,
            //                        });

            //if (!checkLayerState("AIS", "off")) {
            //    map.addLayer(ais);
            //    AISoff = false;
            //}
            //else
            //    AISoff = true;

    /* 
            var aisReload = params.has('ais') ? parseInt(params.get('ais')) : 10;
            if (aisReload > 0) {
                if (aisReload < 10)
                    aisReload = 10;

                setInterval(function() {
                                if (AISoff == false) {
                                    ais.redraw();
                                    console.log('redrawing AIS');
                                }
                            },
                            aisReload*60000);
            }
*/
            // chart marks

            chart = L.tileLayer("https://t1.openseamap.org/seamark/{z}/{x}/{y}.png", 
                                    {
                                        
                                    });

            if (!checkLayerState("chart marks", "off")) 
                map.addLayer(chart);

{% if weathermapAppID != '' %}
            // wind

            wind = L.tileLayer("https://tile.openweathermap.org/map/wind_new/{z}/{x}/{y}.png?appid={{ weathermapAppID }}",
                                    {
                                    });

            if (checkLayerState("wind", "on")) {
                map.addLayer(wind); //  not on by default
            }
            var legend = L.control({position: 'bottomright'});

            legend.onAdd = function (map) {
                console.log('adding legend');
                var div = L.DomUtil.create('div', 'wind legend');
                div.innerHTML = '<img src="../script/images/OWM_windscale.png">';
                return div;
            };

            // legend.addTo(map); // match the layer default

{% endif %}
            // map event handlers

            //turn legend on and off as wind layer comes and goes
            map.on('baselayerchange', function(e) {
                localStorage.setItem('baseLayer', e.name);
            });          
            map.on('overlayadd', function(e) {
                localStorage.setItem('layerStatus_' + e.name, 'on');
                if (e.name === 'wind') 
                    legend.addTo(this);
                else if (e.name === 'AIS') 
                    AISoff = false;
            });          
            map.on('overlayremove', function(e) {
                localStorage.setItem('layerStatus_' + e.name, 'off');
                if (e.name === 'wind')
                    this.removeControl(legend);
                else if (e.name === 'AIS') 
                    AISoff = true;
            });          

            var popup = L.popup({ maxWidth:600, minWidth:400, className: 'weather-popup' });
            //map.on('click', function(evt) {
                //if (markerClicked) {
                //    markerClicked = false;
                //    return;
                //}

                //if (ruler._choice == false && evt.originalEvent.altKey) {
                //    console.log(evt.latlng);
                //    fetchWeather(evt.latlng, popup, map);
                //}

                //if (needLocationSetup == 1) {
                //    console.log('setting up location');
                //    setupLocation(map, layerControl);
                //    needLocationSetup = 0;
                //}
            //});

            map.on('contextmenu', function(evt) {
                console.log(evt.latlng);
                fetchWeather(evt.latlng, popup, map);
            });

            // SSH
        
            ssh = L.tileLayer("https://gibs-{s}.earthdata.nasa.gov/wmts/epsg3857/best/{layer}/default/{time}/{tileMatrixSet}/{z}/{y}/{x}.png",
                                    {
                                        layer: 'JPL_MEaSUREs_L4_Sea_Surface_Height_Anomalies',
                                        format: "image/png",
                                        tileMatrixSet: 'GoogleMapsCompatible_Level6',
                                        time: 'default',
                                        maxNativeZoom: 5,
                                        maxZoom: 9,
                                        opacity: 0.5,
                                    });

            if (checkLayerState("SSH", "on")) 
                map.addLayer(ssh);

            // SST
        
            sst = L.tileLayer("https://gibs-{s}.earthdata.nasa.gov/wmts/epsg3857/best/{layer}/default/{time}/{tileMatrixSet}/{z}/{y}/{x}.png",
                                    {
                                        layer: 'MODIS_Aqua_L3_SST_Thermal_4km_Day_8Day',
                                        format: "image/png",
                                        tileMatrixSet: 'GoogleMapsCompatible_Level6',
                                        time: 'default',
                                        maxNativeZoom: 5,
                                        maxZoom: 10,
                                        opacity: 1.0
                                    });

            if (checkLayerState("SST (MODIS 8-day day)", "on")) 
                map.addLayer(sst);

            // sea ice

            seaIce = L.tileLayer("https://gibs-{s}.earthdata.nasa.gov/wmts/epsg3857/best/{layer}/default/{time}/{tileMatrixSet}/{z}/{y}/{x}.png",
                                    {
                                        layer: 'AMSRU2_Sea_Ice_Concentration_12km',
                                        format: "image/png",
                                        tileMatrixSet: 'GoogleMapsCompatible_Level6',
                                        time: 'default',
                                        maxNativeZoom: 5,
                                        maxZoom: 10,
                                        opacity: 1.0
                                    });

            if (checkLayerState("sea ice", "on")) 
                map.addLayer(seaIce);

            chlA = L.tileLayer("https://gibs-{s}.earthdata.nasa.gov/wmts/epsg3857/best/{layer}/default/{time}/{tileMatrixSet}/{z}/{y}/{x}.png",
                                    {
                                        layer: 'MODIS_Aqua_L2_Chlorophyll_A',
                                        format: "image/png",
                                        tileMatrixSet: 'GoogleMapsCompatible_Level7',
                                        time: 'default',
                                        maxNativeZoom: 6,
                                        maxZoom: 10,
                                        opacity: 1.0
                                    });

            if (checkLayerState("Chlorophyll-A (Aqua MODIS L2)", "on")) 
                map.addLayer(chlA);

            // contours
           
            contours = L.tileLayer("https://tiles.arcgis.com/tiles/C8EMgrsFcRFL6LrL/arcgis/rest/services/GEBCO_contours/MapServer/tile/{z}/{y}/{x}",
                                    {
                                        layer: 'GEBCO contours',
                                        format: "image/png",
                                        maxNativeZoom: 10,
                                        maxZoom: 16,
                                        detectRetina: false,
                                        opacity: 0.6
                                    });

           // contours = L.tileLayer.wms("http://www.opendem.info:80/geoserver/opendem/ows?",
           //                         {
           //                             format: "image/png",
           //                             layers: "opendem:gebco_2021_contours",
           //                             opacity: 0.2,
           //                             // tileSize: 1024,
           //                         });

            if (checkLayerState("GEBCO contours", "on"))
                map.addLayer(contours); // not on by default
            
            // coordinate display

            coord = L.control.coordinates({
                position:"bottomleft", //optional default "bootomright"
                decimals:2, //optional default 4
                decimalSeperator:".", //optional default "."
                labelTemplateLat:"Lat: {y}", //optional default "Lat: {y}"
                labelTemplateLng:"Lon: {x}", //optional default "Lng: {x}"
                enableUserInput:true, //optional default true
                useDMS:false, //optional default false
                useLatLngOrder: true, //ordering of labels, default false-> lng-lat
                labelFormatterLng : formatPosDD, //optional default none,
                labelFormatterLat : formatPosDD, //optional default none
            }).addTo(map);


            // var hamburgerPopup = L.popup().setContent('<ul><li>menu1<li>menu2<li>menu3</ul>');

            var hamburgerBtn = L.easyButton('<span class="hamburger" style="font-size: 28px; margin-top: -3px; display: inline-block;">&#8801;</span>', function(btn, map) {
                toggleHamburger(); // btn.getContainer());
            }).addTo(map);

            // var div = hamburgerBtn.getContainer();

            // ruler tool

            var options = {
                position: 'topleft',
                lengthUnit: {
                    factor: 1, // 0.539956803,    //  from km to nm
                    display: 'km',
                    decimal: 2,
                    label: 'distance'
                },
                export: exportTargets
            };                               
            ruler = L.control.ruler(options);
            ruler.addTo(map);

            map.on('keypress', function(e) { 
                // console.log(e);
                if (e.originalEvent.charCode == 109) { 
                    let id = '' + Math.floor(Date.now()/1000);
                    let html = [
                        formatPos(dd2ddmm(coord.latlng.lat)) + "," + formatPos(dd2ddmm(coord.latlng.lng)),
                        `<span onclick="deleteMark('${id}');">delete</span> <span onclick="activateAsset('${id}');">activate</span>`
                    ].join('<br />');
                    let m = L.shapeMarker(coord.latlng, 
                              {
                                    shape: 'square',
                                    radius: 5,
                                    color: 'magenta',
                                    draggable: 'true',
                              })
                              .bindPopup(html)
                              .addTo(map);
    
                    m.id = id;
                    draggableMarker(map, m);
                    droppedMarks.push(m);

                 } 
            });

            shipCenterToggle = L.control.toggle({ position: 'topleft' }).addTo(map).configure(null, '<span style="font-size: 20px;">&nbsp;&#x1F6A2;</span>');
            console.log('added shipCenterToggle');

            let slider = L.control.slider(sliderUpdateDisplay, {id: 'timeSlider', orientation: 'vertical', position: 'topleft', getValue: sliderUpdateTime });
            slider.addTo(map);

            // var heat = L.popup().setContent('<ul><li>menu1<li>menu2<li>menu3</ul>');

            var heatControlBtn = L.easyButton('<span class="hamburger" style="font-size: 28px; margin-top: -3px; display: inline-block;">&#x1F321;&nbsp;</span>', function(btn, map) {
                toggleHeatControl(); // btn.getContainer());
            }).addTo(map);

            // layer control

            var baseLayers = {
                "OpenSteetMap": osm,
                "NOAA+Stamen": noaa,
            }

            var overlayLayers = {
                "bathymetry": {
                    "GEBCO shading": gebco,
                    "GEBCO contours": contours,
                },
                "satellite": {
                    "SSH": ssh,
                    "SST (MODIS 8-day day)": sst,
                    "sea ice (AMSRU2 12km)": seaIce,
                    "Chlorophyll-A (Aqua MODIS L2)": chlA,
                },
                "chart": {
                    "traffic density": ais,
                    "EEZ": eez,
                    "chart marks": chart,
                },
{% if weathermapAppID != '' %}
                "weather": {
                    "wind": wind,
                },
{% endif %}
            }

            var options = {
                groupCheckboxes: true,
                groupsCollapsable: true,
                // (Optional) The css class(es) used to indicated the group is expanded
                groupsExpandedClass: "glyphicon glyphicon-chevron-down", 
                // (Optional) The css class(es) used to indicated the group is collapsed
                groupsCollapsedClass: "glyphicon glyphicon-chevron-right"
            };

            var layerControl = L.control.groupedLayers(baseLayers, overlayLayers, options).addTo(map);

            let graticule = L.grids.dms()
            // graticule.addTo(map);
            layerControl.addOverlay(graticule, 'grid', "chart"); 
            
            // ice edge first

            //kmz = L.kmzLayer();
            //kmz.on('load', function(e) {
            //    layerControl.addOverlay(e.layer, e.name);
            //});

            // we have to proxy these or we run into CORS problems
            //kmz.load('../proxy/https://usicecenter.gov/File/DownloadCurrent?pId=14', 'Arctic ice edge');
            //kmz.load('../proxy/https://usicecenter.gov/File/DownloadCurrent?pId=22', 'Antarctic ice edge');

            var urls = ['../proxykmz/https://usicecenter.gov/File/DownloadCurrent?pId=14',
                        '../proxykmz/https://usicecenter.gov/File/DownloadCurrent?pId=22'];
            names = ['Arctic ice edge', 'Antarctic ice edge']
            loadKML(map, layerControl, urls, names);

            // KML and snap to KML

            // glider stuff

            // use the KML library vz KMZ as we've already got the plumbing
            // to get it out of the kmz via the server and that lib
            // does a better job of grouping in the layers so we can
            // turn pieces on and off


            // var glider = window.location.pathname.split('/').at(-1)
            var path = window.location.pathname.split('/');
            var glider = null;
            var first = path.indexOf('map') + 1;
            console.log(path);
            console.log(path.length, first);
            if (first <= path.length - 1) {
                glider = path[first];
            }
        
            // var mission = params.has('mission') ? '?mission=' + params.get('mission') : '';
            var mission = params.has('mission') ? params.get('mission') : '';
            var tail = params.has('tail') ? parseInt(params.get('tail')) : -1;

            currMission = mission;

            if (glider !== null) {
                document.title = glider + '-map';
                window.name = glider + '-map';
                lastBounds = loadBounds('' + glider);

                var url;

                if (mission && mission != '')
                   url = `../summary/${glider}?mission=${mission}`;
                else
                   url = `../summary/${glider}`;

                targetsChannel = new BroadcastChannel(glider + '-targets');
                targetsChannel.onmessage = (event) => {
                    getTargetsFromVis(event.data);
                };
               
                fetch(url)
                .then(resp => resp.json()) 
                .then(d => {

                    if (mission == null || mission == '') {
                        mission = d['mission']['mission'];
                        currMission = mission;
                    }
                    loadGliderPosition(map, layerControl, glider, mission);
                    loadGliderKML(map, layerControl, [ glider ], [ mission ], tail, lastBounds, true, true);
                    loadGliderDAC(map, layerControl, path[first], mission); 

                    L.easyButton('<img src="../script/images/diveplot_icon.png">', function(){
                        if (mission != '')
                            window.open('../' + glider + '?mission=' + mission, 'SG' + glider);
                        else
                            window.open('../' + glider, 'SG' + glider);
                    }).addTo(map);
                });

            }
            else {
                document.title = 'map';
            }


            loadExtras(map, layerControl, glider, mission, tail);

            if (params.has('ship')) {
                if (params.get('ship') == 'me') {
                    console.log('marking location setup');
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('basicInfo').innerHTML = 'Click to start location';
                    document.getElementById('basicInfo').addEventListener('click', setupLocation);
                }
                else {
                    setupShip(map, layerControl, params.get('ship'), null);
                }
            }

            if (params.has('rings')) {
                var ranges = params.get('rings').split(',');
                for (var i = 0 ; i < ranges.length ; i++) {
                    if (ranges[i].includes('nm'))     
                        ranges[i] = parseFloat(ranges[i].split('n')[0])*1852.0;
                    else if (ranges[i].includes('km'))
                        ranges[i] = parseFloat(ranges[i].split('k')[0])*1000.0;
                    else if (ranges[i].includes('m'))
                        ranges[i] = parseFloat(ranges[i].split('m')[0]);
                    else 
                        ranges[i] = parseFloat(ranges[i]);
                }
                setupShipRings(map, layerControl, ranges);
            }

            if (params.has('also')) {
                var p_also = params.get('also').split(',');
                var d_also = [];
                for (var k = 0 ; k < p_also.length  ; k++) {
                    // old school mission spec - not path spec
                    pieces = p_also[k].split('/');
                    if (pieces.length == 2)
                        d_also.push({'glider': parseInt(pieces[0]), 'mission': pieces[1]});
                    else
                        d_also.push({'glider': parseInt(pieces[0]), 'mission': ''});
                }
                loadAlso(map, layerControl, d_also, tail, 0, '');
            }

            if (params.has('sa')) {
                let sa = params.get('sa'); 
                urls = [ sa ];
                var labels = [ sa.split('/').slice(-1) ];
                console.log(sa + ' from query line');
                loadSA(map, layerControl, urls, labels);
            }

            setupStream();

        </script>
    </body>
</html>
